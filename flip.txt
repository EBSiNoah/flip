입력된 배열의 index 값과 해당 index 의 value 값의 합계와 비교를 한다.
같은 경우는 value 가 0이란 뜻이고, 다른 경우는 1이라는 뜻이니
이를 이용해서 덩어리들의 시작점과 끝점을 알수 있을 것이다.
시작과 끝점을 알기보다는 덩어리의 개수를 세는게 더 쉬운 방법 같다.






두가지 문제가 발생하였다.
첫번째는 append를 하는 과정에서 원소가 없는 배열을 같이 append 하다보니,
배열 원소의 개수를 비교해서 최소값을 결과로 반환한다는 계획은 무산되었다.
두번째는 append의 조건인데, 입력 배열의 index 와 해당 value 의 합계와의 비교하는데
마지막 값이 변화하는 경우 원소 배열에 포함되지 않는다는 것이었다.














입력받은 배열에서 각 덩어리들은 하나의 원소로 다시 볼 수 있다.
하나의 묶음으로 볼수 있는 것이다.
그렇게 되면 새로 만들어진 배열의 크기와 배열의 전체 값의 합계를 비교하면 원하는 값을 얻을수 있을 것이다.













append는 익숙했지만 remove 기능을 익혀야 할 때가 된 것 같다.
반복문을 도는데 복사된 배열이 아닌 원본 배열을 돌아본다.
이유가 뭐였을까?













원리는 간단하다.
배열을 한바퀴 돌면서 아래의 행동을 한다.
1. 비교하고 싶은 값은 배열의 첫번째 값에서 출발한다.
2. 바로 다음 값과 비교한다.
3. 같으면 remove한다.
4. remove 되었을 경우 다음 원소로 넘어가지 않는다. 특성상 비워진 자리를 다음 원소가 알아서 내려와서 채워주기 때문이다.
5. 다르면 다음 원소로 넘어가고, 비교할 값으로 저장한다.
6. 2~5를 반복한다.












remove 는 ㅇ입력된 값이 가장 처음으로 발견된 위치를 삭제하는 기능ㅇ이었다
pop을 사용하면 내가 원하는 위치의 원소를 제거할수 있다.
사용자 입력을 받기 위해 input() 함수를 사용한다.
type( value ) 로 입력받은 자료형을 알수 있고
ord() 라는 함수로 입력받은 char 자료형의 unicode 순서를 알수 있다.
반례를 따로 발견할수 없었다. 그래서 일단 처음의 이 답변이 맞다고 가정하고
다른 답변도 알아보기로 했다.
c++로 변환하는 과정에서 문제가 생겼다.
erase 에 문제가 있었던 것일까?
프로그래밍 언어끼리 비슷하다곤 하지만 결국 근본적인 차이가 있다.
c++가 내 주력이고, python이 보조인데,
python으로 작성하면 간단해 보이는건 맞는것 같다.
작성된 코드를 변환하는 과정에서 내가 봐야할 것은
코드가 아니라 논리였음을 다시 깨닫게 되었다.
논리를 표현한게 코드지만 코드를 보고 논리를 알수는 없다
비가역적인 관계인것이다.
그래서 소프트웨어 공학에서 문서화에 대해서 중요하게 다뤘는지 알것 같다.
최소한 공학도라면 갖춰야될 기본인 것이었다.
앞으로 코드를 작성할 경우에 사용자 입력이 아닌 입출력 테이블을 따로 만들어보자

궁금한 점이 하나 생겼다.
속도를 비교해보고 싶었다.
c언어의 속도가 압도적으로 빠르다고 했다.
이번에 제출한 답변을 바탕으로 걸리는 시간을 비교해보고 싶어졌다.

또다른 사실을 알았다.
python의 list는 minus index 의 경우 고리모양 자료형이라서 맨 뒤로 가지만
c++의 array는 그렇지 않았다. 말그대로 뒤로 가는 것이었다.
그 말인 즉슨 python의 list 같은걸 만들고 싶거든 직접 만들던가
아니면 내가 모르는것이 있던거 둘중 하나라는 뜻이다.

그래서 내가 시도한 방법은 negative index 위치에 value를 넣어서 해결하려고 했다.
그런데 절대 금기였다.
undefined behavior 이라는 개념인데,
컴파일러가 잡아내지 않는 ㅊ치명적인 행동이라는 것이다.
보기에는 작동되니 괜찮아보이지만 이게 어떤 결과를 가져올지 아무도 알수 없다.
아마 채점 결과에 틀렸다고 한 이유가 여기에 있지 않을까?
이런 개념이 c++에만 있을리가 없다
python 의 list 또한 사실 negative index 를 맨 뒤로 보내는 것이 아닌 undefined behavior 였던게 아닐까?

아스키코드에 예를 들어 또 하나 새롭게 알게된것
수학적 계산과 논리적 계산에 대한 것인데,
마치 책 귀퉁이 어딘가 보이지도 않는 곳에 적혀있어서 내가 신경을 쓰지 않은 부분이었거나
기능이 비슷하다고 생각되어서 굳이 배우려 하지 않았거나
아무튼 연산자의 이야기 같은데
'&', '>>', '<<' 뒤의 두놈은 비트 연산자인데 살 기능은 모른다.
'&' 는 존재자체도 모른다. 얘가 있으면 "|" 또한 존재하지 않겠는가?
아스키 코드니까 알고있던 지식을 이용해서 수학적 계산을 할 수 있었지만 만약에 그게 아니라면?
논리적으로 결과를 도출해야 한다는 것이다.

이 문제를 다른 시점으로 관찰하고 또다른 답변을 내놓아야 한다.
일종의 기하학의미의 편미분 행동이라는 것이다.
우메함의 봉우리를 지나 골짜기로 계속 돌진하고 있을 뿐이었다.
-------------------------------------12.08--------------------------------------
undefined behavior 문제를 해결하고 나서 하고 싶었던걸 해보았다.

c언어가 속도가 빠르다고 들어만 봤는데 그 결과를 실제로 보니 신기했다.
분명 두 프로그램 간에 논리적인 차이는 없는데 속도차이가 100배 이상 나는 모습을 보여주었다.

------------------------------------12.10------------------------------------
또다른 답변을 만드는 과정이다.
입력되는 배열의 원소는 0 또는 1뿐이다.
배열을 2개씩 묶어서 보면 0과 1로 이루어진 4가지 형태가 나오는 것을 알 수 있었다.
같은 숫자가 연달아 나오는 경우는 고려 대상이 아니고, [0,1], [1,0] 인 경우를 중점으로 보면
일종의 규칙이 나타나는 것을 알 수 있다.
배열에 1이 많은 경우, [0,1] 모양이 나타나는 개수가 답변이 되고, 
반대의 경우는 [1,0] 모양의 개수가 답변인데
이것에 대해 전체적인 데이터를 들여다 보아야 한다.

fundamental, 이 강좌를 듣는 내내 가장 많은 언급이 되었다. 근본적인 방법, 다른 요소에 기대지 않고 기본적인 방법으로 문제를 해결하는 능력

coverage, 모든 경우의 수를 점검하는것은 거의 불가능하다. 다만 최대한 많이 볼수 있도록 데이터가 어떻게 움직이는지 자세히 알고 있어야 한다.

데이터의 움직임을 보고 이게 어떤것인지 파악하는 것도 중요한것 같다. 약간의 상상력이 필요한 대목 인것 같다.

아직 많이 부족하다, 그중에서 특히 하나를 꼽는다면 내 생각에는 상상력 같다.
데이터를 보고는 있지만 이게 무엇을 의미하는지, 규칙이 있는건지, 애초에 그러한 데이터를 만들수 있는지
이런 점이 계속해서 발목을 잡는것 같다.

처음 답변을 내놓는것은 어떻게든 가능하지만, 다른 시야로 보면서 다른 답변을 내는것이 나는 아직 상상조차 힘들다.
-------------------------------------------------12.16.-------------------------------------------------
전체 데이터 테이블을 만들어 보았다.
그 결과 입력된 행렬의 첫번째 원소가 0 이면 [0,1] 모양이 나타난 횟수가 답변이 되고, 1이면 [1,0] 모양이 나타난 횟수가 답변이 된다는 것을 알았다.
뭔가 기분이 답지를 본것 같다. 결국에 스스로 알아낸 방법이 아니라서 그런가보다.
세번째 방법은 여태껏 해온 과정을 복기하면 알게 될것 이라 하였다.
생각해보면 지금까지 과정은 모두 비슷한 성격을 가지고 있었다.
전체 데이터 테이블을 만들어보면 성질을 찾을수 있다는게 다들 공통점이었다.
관점을 바꿔서 생각해 보아야 겠다.




























http://ebook.pldworld.com/_eBook/%EC%9B%94%EA%B0%84%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/imaso-200401-p3554.pdf
http://meseec.ce.rit.edu/551-projects/spring2017/2-3.pdf